클래스(반, 공통 요소가 모여있는 곳)

	붕어빵 틀

	변수 : 반복되는 값을 쉽게 관리하기 위해서
	메소드 : 반복되는 기능들을 쉽게 관리하기 위해서
	클래스 : 반복되는 변수와 메소드를 쉽게 관리하기 위해서

	1. 주어이다.
		모든 문장 맨 앞에 클래스가 나오고
		영어는 맨 앞을 항상 대문자로 적는다.
		따라서 주어가 클래스이고 대문자로 시작한다.(무조건은 아님)
	
		Monkey.eat("Banana")
		[주어]  [동사]  [목적어]

	2. 타입이다.
		클래스는 추상적인 개념이고 이 클래스안에는 필드가
		존재한다. 필드에 접근하기 위해서는 추상적인 개념을
		구체화한 "객체"가 필요하고 영어로 instance variable
		이라고 한다.

		instance는 예, 예시이고 추상적인 개념의 한 예시로서
		객체가 나오기 때문에 instance variable이라 부른다.
		(자동차는 자동차인데 예를 들어 내차 말이야~)
		 [클래스]			[객체]
		
		추상적인 개념의 클래스를 객체로 만드는 작업을 
		객체화라고 하며, instance라고 한다.

		따라서 클래스는 그 객체의 타입이다.

클래스 선언

	class 클래스명 : 
		필드(객체, 메소드)

클래스 사용

	객체
		붕어빵
		추상적인 개념인 클래스를 실체화 시켜주는 존재

		객체명 = 클래스명()

.(하위연산자)
	A.b : A안의b / A의b

객체 사용
	객체.필드명
	객체.메소드명()

	클래스는 단 한개이다. 하지만 그 클래스 타입의 객체는
	여러개이다. 따라서 한 개뿐인 클래스에서 객체들을
	모두 관리해야한다. 각 객체들은 서로 다른 주소값을 
	가지고 있고 그 주소값으로 구분점을 삼는다.
	객체에.(하위연산자)을 사용하면 자동으로 주소값이
	클래스로 넘어가고 그 주소값을 self라는 변수가 받는다.
	클래스 내부에서 self.필드명으로 사용하게 되면
	어떤 객체에서 접근하는 지를 클래스 하나로도 관리할 수
	있게된다. 즉 self란 객체구별을 위한 변수이다.

생성자
	클래스 이름 뒤에 소괄호()
	클래스 선언시 자동으로 기본 생성자가 만들어지고
	코드상에는 나타나지 않는다.	
	메소드와 비슷하지만 return 불가능
	생성자 호출시 
	1. 클래스의 필드와 동일하게 하나를 복사해서
		만들고 그 주소값을 가지고 온다.
	2. 생성자 선언부에 있는 코드를 전부 실행

생성자 선언

	def __init__(self,변수1,변수2,...):
		수행할 문장

































